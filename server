#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <netdb.h>
#include <pthread.h>
/*	SENDER		*/

#define BUFF_SIZE 1024
#define TIMETOLIVE 15
#define CATEGORIES 3
#define PORTUDP 1234
#define PORTTCP 12345
#define MULTICASTG1 "224.61.0.4"
#define MULTICASTG2 "224.61.0.5"
#define MULTICASTG3 "224.61.0.6"

/*messages we send*/
#define HELLOACK 0
#define INFOACK 1
#define QUESTION 2
#define FIN 3

/*messages we can receive*/
#define HELLO 0
#define INFO 1 // ASKSONG
#define ANSWER 2 //UPSONG
#define QUIT 3

/* A linked list node */
typedef struct udpNodes {
    int CategoryFD;
    int CategoryNumber;
    uint8_t questionNameSize;
    char* questionName;
    FILE *fp;
    struct sockaddr_in category;
    struct udpNodes *next;
} udpNode;

typedef struct tcpClients {
    int clientFD;
    int clientID;
    int clientAge;
    char clientNickName;
    int clientNickNameSize;
    pthread_t th;
    struct sockaddr_in client;
    struct tcpClients *next;
} tcpClient;

void* welcome_func();
int winnerCalc();
void scoreCalc();
void* TCPManager(void* client);
void shutdown_and_goodbye();
void invalid_command(int type, tcpClient *client);
void removeClinet(tcpClient* del);
void releaseUdpNode();
void releaseTCPclients();

udpNode *head = NULL, *temp, *temp2 , *temps[3] ;
tcpClient *TCPhead = NULL, *Ttemp = NULL, *Ttemp2 = NULL;
int welcome_socket, client_socket_fd, noOfClients = 0, portTCP, uploadFlag = 0, qFlaf = 1 ,numOfPlay = 0;
uint8_t temp8;
uint16_t numSongs, temp16, temp162, portUDP = PORTUDP;
uint32_t multiCastG[3], temp32;
struct sockaddr_in client_addr;
pthread_mutex_t lock;
pthread_t welcome_th;
u_char ttl = TIMETOLIVE;
char* Q1[] = {"yes?","no?","ok?"};
char** Q[] = {Q1};
int* A[] = {0,1,2,3,4};
int q_now = 0;
int* answers[4] = {NULL,NULL,NULL,NULL};
int* score[4] = {0,0,0,0};
int IDs[4] = {0,0,0,0};


int main(int argc, char *argv[]) {
    socklen_t addrSize;
    int threadVal, one = 1;
    int server_socket_fd,state;
    struct sockaddr_in serv_addr;
    int n, i, byte_no, counter = 0, sum_of_data_sent = 0;
    char *quesionBuf[BUFF_SIZE]; // fill in the buffer in Q.
    // error check command line arguments
    if (argc < 4) {
        perror("ERROR, arguments are missing\n");
        exit(EXIT_FAILURE);
    }
    // set the UDP port multicast
//    portUDP = atoi(argv[3]);
    multiCastG[0] = inet_addr((const char *) MULTICASTG1);
//    multiCastG[1] = inet_addr((const char *) MULTICASTG2);
//    multiCastG[2] = inet_addr((const char *) MULTICASTG3);
    memset(temps,'\0',3);
    //numSongs = argc - 4;  todo delete
    //opening udp threads for songs received in argv
    for(i = 0; i < 1; i++) {
        temp = (udpNode *)malloc(sizeof(udpNode));
        if(!temp) {
            printf("ERROR malloc udpNode\n");
            shutdown_and_goodbye();
            return 1;
        }
        temp -> CategoryNumber = i;
        temp -> category.sin_family = AF_INET;
        temp -> category.sin_port = htons(portUDP);
        temp->category.sin_addr.s_addr = multiCastG[i];
        temp->CategoryFD = socket(AF_INET, SOCK_DGRAM, 0);
        if(temp->CategoryFD < 0) {
            perror("ERROR in opening UDP socket\n");
            shutdown_and_goodbye();
            return 1;
        }
        setsockopt(temp -> CategoryFD, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
        temps[i] = temp;
    }
    // setup socket - set TCP !
    welcome_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (welcome_socket < 0) {
        perror("ERROR opening socket");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }
    // setup server information
    memset((char *) &serv_addr, 0, sizeof(serv_addr));
    portTCP = atoi(PORTTCP); //tcp port
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(portTCP); // tcp port
    memset(serv_addr.sin_zero, '\0', sizeof(serv_addr.sin_zero));

    // resolve binding issues in the os
    setsockopt(welcome_socket,SOL_SOCKET,SO_REUSEADDR,(char *) &one,sizeof(int));

    // bind the socket to an address
    if (bind(welcome_socket, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        perror("ERROR on binding");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }

    threadVal = pthread_create(&welcome_th, NULL, welcome_func, NULL);
    if(threadVal != 0 ) {
        perror("ERROR opening welcome thread\n");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }
    i = 0 ;
    while(qFlaf)
    {
            // save question into buffer
        if(sendto(temps[0]->CategoryFD, quesionBuf[i], sizeof(quesionBuf[i]), 0, (struct sockaddr*)
                &temp->category, sizeof(temp->category)) < 0)
        {
            perror("ERROR in sending data:");
            shutdown_and_goodbye();
            return 1;
        }
        i++ ;
    }
//        usleep(62500);
    shutdown_and_goodbye();
    pthread_join(welcome_th, NULL);
    return 1;
}

// welcome
void* welcome_func() {
    int thVal, retVal, i;
    char input[10], addr[INET_ADDRSTRLEN], buff[3];
    tcpClient *cPtr;
    socklen_t addr_size;
    fd_set fds;
    udpNode *wPtr;

    printf("Entering welcome thread\n");
    listen(welcome_socket, 100);  // limit to 1 and try to add 2.
    addr_size = sizeof(client_addr);
    while(qFlaf) {
        memset(input, '\0', 10);
        printf("Please type q to quit\n");
        FD_ZERO(&fds);
        FD_SET(welcome_socket, &fds);
        FD_SET(fileno(stdin), &fds);
        retVal = select(FD_SETSIZE, &fds, NULL, NULL, NULL);
        if(retVal <= 0 && (errno != EINTR))
        {
            printf("ERROR in select, HELLO\n");
            shutdown_and_goodbye();
            qFlaf = 0;
            pthread_exit(&welcome_th);
        }
        // checks if the welcome_socket is in the table
        if(FD_ISSET(welcome_socket, &fds))
        {
            noOfClients++;
            Ttemp = (tcpClient*)malloc(sizeof(tcpClient));
            if(Ttemp == NULL)
            {
                printf("ERROR allocating memory for tcp client\n");
                shutdown_and_goodbye();
                qFlaf = 0;
                pthread_exit(&welcome_th);
            }
            Ttemp -> client.sin_family = AF_INET; //   IPv4
            Ttemp -> client.sin_addr.s_addr = htonl(INADDR_ANY);
            Ttemp -> client.sin_port = htons(portTCP);
            Ttemp -> clientFD = accept(welcome_socket, (struct sockaddr *) &(Ttemp -> client), &addr_size);
            // thread creating for each client
            thVal = pthread_create(&(Ttemp -> th), NULL, TCPManager, Ttemp);
            if(thVal != 0)
            {
                printf("ERROR opening thread\n");
                shutdown_and_goodbye();
                qFlaf = 0;
                pthread_exit(&welcome_th);
            }
            Ttemp -> next = NULL;
            if(noOfClients == 1)
            {
                TCPhead = Ttemp;
                Ttemp2 = Ttemp;
                Ttemp2 -> next = NULL;
            } else
            {
                Ttemp2 -> next = Ttemp;
                Ttemp2 = Ttemp;
                Ttemp = Ttemp -> next;
            }
        } else if (FD_ISSET(fileno(stdin), &fds))
        {
            scanf("%10s", input);
            if(strlen(input) != 1)
                input[0] = 0; ///so it will go to default
            switch(input[0])
            {
                case 'q':
                    printf("We are closing the server after user request, we free all the memory and close all the sockets\n");
                    shutdown_and_goodbye();
                    qFlaf = 0;
                    break;
                default:
                    printf("Please retry by enter a valid command\n");
            } //switch
        } //else if
    } //while
}

// TCP Manager
void* TCPManager(void* client) {
    int i=0, helloFlag = 1, retVal, byteCount, num_parts, alreadyHave = 0, tcpqFlag = 1, size0fanswer ,yesno;
    tcpClient *cl = (tcpClient*)client, *tPtr;
    fd_set fds;
    uint8_t commandType;
    uint16_t catnum;
    char buffer[BUFF_SIZE], inbox[BUFF_SIZE + 1];
    udpNode *sPtr, *tempi;
    char *newSongName;
    //struct for Timeout in select
    struct timeval timeout;
    /*if there is a problem with a specific client we are closing him only*/
    while(tcpqFlag) {
        FD_ZERO(&fds);
        FD_SET(cl -> clientFD , &fds);
        if(helloFlag) { //the hello (connection) massage
            //define the time for timeout
            timeout.tv_sec = 0;
            timeout.tv_usec = 300000;
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
        } else {
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, NULL);
        }
        if(retVal <= 0 && (errno != EINTR)) {
            if(helloFlag) {
                printf("Timeout - didn't received HELLO\nRemoving client\n");
                removeClinet(cl);
            }
            break;
        }
        if(FD_ISSET(cl -> clientFD, &fds)) // if the fd is in the list
        {
            // receiving massage from client
            if((byteCount = read(cl -> clientFD, inbox, BUFF_SIZE)) <= 0)
            {
                printf("client closed the connection\n");
                removeClinet(cl);
                tcpqFlag = 0;
                break;
            }
            commandType = (uint8_t) inbox[0];
            switch(commandType) {
                case HELLO:
                    if(!helloFlag) {
                        invalid_command(3, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(byteCount != 3) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(inbox[1] || inbox[2]) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    helloFlag = 0;
                    buffer[0] = HELLOACK;
                    //temp162 = htons(numSongs);
                    temp16 = htons(portUDP);
                    temp32 = htonl(multiCastG[0]);
                    //memcpy(buffer + 1, &temp162, 2);
                    memcpy(buffer + 1, &temp32, 4);
                    memcpy(buffer + 5, &temp16, 2);
                    if(send(cl -> clientFD, &buffer, 7, 0) != 7) {
                        printf("wrong amount of byte sent\n");
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
                    break;
                case INFO:
                    if(helloFlag) {
                        invalid_command(2, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(byteCount != 3) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
//                    catnum = 1;
                    //staNum = inbox[1]*10;
                    //staNum += inbox[2];
//                    if(staNum >= numSongs) {
//                        invalid_command(2, cl);
//                        tcpqFlag = 0;
//                        break;
//                    }
//                    sPtr = head;
//                    while(sPtr != NULL) {
//                        if(sPtr -> CategoryNumber == catnum)
//                            break;
//                        sPtr = sPtr -> next;
//                    }
                    /* age,sizename,name got from the client */
                    cl->clientNickNameSize = inbox[2];
                    cl->clientAge = inbox[1];
                    memcpy(cl->clientNickName,inbox[3],cl->clientNickNameSize);
                    for (int j = 0; j < 4; ++j) {
                        if(IDs[j] == 0)
                        {
                            cl->clientID = j;
                            IDs[j] = 1 ;
                            break;
                        }
                    }
                    memset(buffer, '\0', BUFF_SIZE);
                    buffer[0] = INFOACK;
                    buffer[1] = cl->clientID;
//                    memcpy(buffer + 2, sPtr -> songName, sPtr -> songNameSize);
                    if((byteCount = send(cl -> clientFD, &buffer, 2 , 0)) != 2 ) {
                        printf("announce: wrong amount of byte sent\n");
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
                RESUME :
                    while (noOfClients != 4)
                    if (noOfClients == 4)
                    {
                        memset(buffer, '\0', BUFF_SIZE);
                        buffer[0] = QUESTION;
                        int size0fQ = sizeof(Q1[0]);
                        buffer[1] = size0fQ;
                        memcpy(buffer+2 ,Q1[0],size0fQ);
                        q_now ++ ;
                        if(sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                               (struct sockaddr*) &temp->category,
                                                       sizeof(temp->category)) != (2+size0fQ))
                                                       {
                            printf("announce: wrong amount of byte sent\n"); // change
                               removeClinet(cl);
                               tcpqFlag = 0;
                               break;
                        }
                    }
                    break;
                case ANSWER:
                        size0fanswer = inbox[1];
                        memcpy(answers[cl->clientID-1],inbox[2],size0fanswer);
                        // todo wait some time for the data to calculate ? to all the clients
                        scoreCalc();
                        // send another question
                        if(q_now < 5)
                        {
                            memset(buffer, '\0', BUFF_SIZE);
                            buffer[0] = QUESTION;
                            int size0fQ = sizeof(Q1[q_now]);
                            buffer[1] = size0fQ;
                            memcpy(buffer+2 ,Q1[q_now],size0fQ);
                            q_now ++ ;
                            if(sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category)) != (2+size0fQ))
                            {
                                printf("announce: wrong amount of byte sent\n"); // change
                                removeClinet(cl);
                                tcpqFlag = 0;
                                break;
                            }
                        }
                        else
                        {
                            memset(buffer, '\0', BUFF_SIZE);
                            buffer[0] = FIN;
//                            buffer[1] = 2;
                            /**------------------------------todo--------fill up the winner------------------------------
                            do func that return Number of winner yaani 0011 = 3 = 2 winners id 0+1 (0-3)
                             good year
                             add (sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category))
                            ***/
                            int winneris = winnerCalc();
                            buffer[1] = winneris ;
                            if(sendto(temp->CategoryFD,buffer,2 ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category)) != 2)
                            {
                                printf("announce: wrong amount of byte sent\n"); // change
                                removeClinet(cl);
                                tcpqFlag = 0;
                                break;
                            }
                        }
                case QUIT:
                    yesno = inbox[1];
                    if(yesno == 0) {
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
                    else
                    {
                        goto RESUME;
                    }
                default:
                    invalid_command(5, cl);
            }//switch
        }//if fd_isset
    }//while 1
}
void scoreCalc()
{
    int min = 3001;
    int temp[4] ;
    for (int i = 0; i < 4; ++i)
    {
        temp[i] = abs(answers[i]-A[q_now]);
        if(min > temp[i])
        {
            min = temp[i];
        }
    }
    for (int i = 0; i < 4; ++i)
    {
        if(temp[i] == min)
        {
            score[i] ++ ;
        }
    }
}

int winnerCalc()
{
    int max = -1 ;
    int k = 1 ;
    for (int i = 0; i < 4; ++i) {
        if(score[i] > max)
        {
            max = score[i];
        }
    }
    for (int i = 0; i < 4; ++i) {
        k = k << 1;
        if(score[i] == max)
        {
            k = k|1;
        }
    }
    return k ;
}

void removeClinet(tcpClient* del)
{
    pthread_mutex_lock(&lock);
    Ttemp = TCPhead;
    IDs[del->clientID] = 0 ;
    if(del == TCPhead) {
        if(del -> next == NULL) {//if there is only one client
            if(close(del -> clientFD) < 0)
                perror("ERROR closing socket\n");
            free(del);
            noOfClients = 0;
            TCPhead = NULL;
        } else {
            Ttemp2 = TCPhead -> next;
            if(close(del -> clientFD) < 0)
                perror("ERROR closing socket\n");
            free(del);
            noOfClients -- ; // noOfClients = 0 ?? 
            TCPhead = Ttemp2;
        }
    } else {//if del != head
        while(Ttemp != del) {
            Ttemp2 = Ttemp; //holds the prev
            Ttemp = Ttemp -> next;
        }
        Ttemp2 -> next = Ttemp -> next; //prev points to the next problem with NULL ?
        noOfClients--;
        if(close(del -> clientFD) < 0)
            perror("ERROR closing TCP socket\n");
        free(Ttemp);
    }//else
    pthread_mutex_unlock(&lock);
    
}
