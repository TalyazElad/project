#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>
/*	SENDER		*/

#define BUFF_SIZE 1024
#define CATEGORIES 3
#define PORTUDP 1234
#define PORTTCP 12345
#define MULTICASTG1 "224.4.0.5"
#define MULTICASTG2 "224.61.0.5"
#define MULTICASTG3 "224.61.0.6"

/*messages we send*/
#define HELLOACK 0
#define INFOACK 1
#define QUESTION 2
#define FIN 3
#define INVALIDCOMMAND 4

/*messages we receive*/
#define HELLO 0
#define INFO 1
#define ANSWER 2
#define QUIT 3

/* A linked list node */
typedef struct udpNodes {
    int CategoryFD;
    int CategoryNumber;
    struct sockaddr_in category;
    struct udpNodes *next;
} udpNode;

typedef struct tcpClients {
    int clientFD;
    int clientID;
    int clientAge;
    char clientNickName;
    int clientNickNameSize;
    pthread_t th;
    struct sockaddr_in client;
    struct tcpClients *next;
} tcpClient;


void* welcome_func();
int winnerCalc();
void scoreCalc();
void* TCPManager(void* client);
void shutdown_and_goodbye();
void invalid_command(int type, tcpClient *client);
void removeClinet(tcpClient* del);
void releaseUdpNode();
void releaseTCPclients();

udpNode *head = NULL, *temp, *temp2 , *temps[3] ;
tcpClient *TCPhead = NULL, *Ttemp = NULL, *Ttemp2 = NULL;
int welcome_socket , noOfClients = 0, portTCP, qFlaf = 1 ;
uint16_t  temp16, portUDP = PORTUDP;
uint32_t multiCastG[3], temp32;
struct sockaddr_in client_addr;
pthread_mutex_t lock;
pthread_t welcome_th;
char* Q1[] = {"yes?","no?","ok?"};
char** Q[] = {Q1};
int* A[] = {0,1,2,3,4};
int q_now = 0;
int* answers[4] = {NULL,NULL,NULL,NULL};
int* score[4] = {0,0,0,0};
int IDs[4] = {0,0,0,0};
int i , j ;
unsigned char ttl = 32;


int main() {
    int threadVal, one = 1;
    struct sockaddr_in serv_addr;
    int i;
    // set the UDP port multicast
//    portUDP = atoi(argv[3]);
    multiCastG[0] = inet_addr((const char *) MULTICASTG1);
//    multiCastG[1] = inet_addr((const char *) MULTICASTG2);
//    multiCastG[2] = inet_addr((const char *) MULTICASTG3);
    memset(temps,'\0',3);
    for(i = 0; i < 1; i++) {
        temp = (udpNode *)malloc(sizeof(udpNode));
        if(!temp) {
            printf("ERROR malloc udpNode\n");
            shutdown_and_goodbye();
            return 1;
        }
        temp -> CategoryNumber = i;
        temp -> category.sin_family = AF_INET;
        temp -> category.sin_port = htons(portUDP);
        temp->category.sin_addr.s_addr = multiCastG[i];
        temp->CategoryFD = socket(AF_INET, SOCK_DGRAM, 0);
        if(temp->CategoryFD < 0) {
            perror("ERROR in opening UDP socket\n");
            shutdown_and_goodbye();
            return 1;
        }
        setsockopt(temp -> CategoryFD, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
        if(i == 0) {
            head = temp;
            temp2 = head;
            head -> next = NULL;
        } else {
            temp2 -> next = temp;
            temp2 = temp2 -> next;
            temp = temp2;
        }
    }
    // setup socket - set TCP !
    welcome_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (welcome_socket < 0) {
        perror("ERROR opening socket");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }

    // setup server information
    memset((char *) &serv_addr, 0, sizeof(serv_addr));

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port = htons(PORTTCP); // tcp port
    memset(serv_addr.sin_zero, '\0', sizeof(serv_addr.sin_zero));

    // resolve binding issues in the os
    setsockopt(welcome_socket,SOL_SOCKET,SO_REUSEADDR,(char *) &one,sizeof(int));

    // bind the socket to an address
    if (bind(welcome_socket, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0) {
        perror("ERROR on binding");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }

    threadVal = pthread_create(&welcome_th, NULL, welcome_func, NULL);
    if(threadVal != 0 ) {
        perror("ERROR opening welcome thread\n");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }
//    shutdown_and_goodbye();
    pthread_join(welcome_th, NULL);
    return 1;
}

// welcome
void* welcome_func() {
    int thVal, retVal, i;
    char input[10], addr[INET_ADDRSTRLEN], buff[3];
    tcpClient *cPtr;
    socklen_t addr_size;
    fd_set fds;
    udpNode *wPtr;

    printf("Entering welcome thread\n");
    listen(welcome_socket, 100);  // limit to 1 and try to add 2.
    addr_size = sizeof(client_addr);
    while(qFlaf) {
        memset(input, '\0', 10);
        printf("Please type q to quit\n");
        FD_ZERO(&fds);
        FD_SET(welcome_socket, &fds);
        FD_SET(fileno(stdin), &fds);
        retVal = select(FD_SETSIZE, &fds, NULL, NULL, NULL);
        if(retVal <= 0 && (errno != EINTR))
        {
            printf("ERROR in select, HELLO\n");
            shutdown_and_goodbye();
            qFlaf = 0;
            pthread_exit(&welcome_th);
        }
        // checks if the welcome_socket is in the table
        if(FD_ISSET(welcome_socket, &fds))
        {
            noOfClients++;
            Ttemp = (tcpClient*)malloc(sizeof(tcpClient));
            if(Ttemp == NULL)
            {
                printf("ERROR allocating memory for tcp client\n");
                shutdown_and_goodbye();
                qFlaf = 0;
                pthread_exit(&welcome_th);
            }
            Ttemp -> client.sin_family = AF_INET; //   IPv4
            Ttemp -> client.sin_addr.s_addr = htonl(INADDR_ANY);
            Ttemp -> client.sin_port = htons(portTCP);
            Ttemp -> clientFD = accept(welcome_socket, (struct sockaddr *) &(Ttemp -> client), &addr_size);
            // thread creating for each client
            thVal = pthread_create(&(Ttemp -> th), NULL, TCPManager, Ttemp);
            if(thVal != 0)
            {
                printf("ERROR opening thread\n");
                shutdown_and_goodbye();
                qFlaf = 0;
                pthread_exit(&welcome_th);
            }
            Ttemp -> next = NULL;
            if(noOfClients == 1)
            {
                TCPhead = Ttemp;
                Ttemp2 = Ttemp;
                Ttemp2 -> next = NULL;
            } else
            {
                Ttemp2 -> next = Ttemp;
                Ttemp2 = Ttemp;
                Ttemp = Ttemp -> next;
            }
        } else if (FD_ISSET(fileno(stdin), &fds))
        {
            scanf("%10s", input);
            if(strlen(input) != 1)
                input[0] = 0; ///so it will go to default
            switch(input[0])
            {
                case 'q':
                    printf("We are closing the server after user request,\nwe free all the memory and close all the sockets\n");
                    shutdown_and_goodbye();
                    qFlaf = 0;
                    break;
                default:
                    printf("Please retry by enter a valid command\n");
            } //switch
        } //else if
    } //while
}

// TCP Manager
void* TCPManager(void* client) {
    int i=0, helloFlag = 1, retVal, byteCount, num_parts, alreadyHave = 0, tcpqFlag = 1, size0fanswer ,yesno;
    tcpClient *cl = (tcpClient*)client, *tPtr;
    fd_set fds;
    uint8_t commandType;
    uint16_t catnum;
    char buffer[BUFF_SIZE], inbox[BUFF_SIZE + 1];
    udpNode *sPtr, *tempi;
    //struct for Timeout in select
    struct timeval timeout;
    /*if there is a problem with a specific client we are closing him only*/
    while(tcpqFlag) {
        FD_ZERO(&fds);
        FD_SET(cl -> clientFD , &fds);
        if(helloFlag) { //the hello (connection) massage
            //define the time for timeout
            timeout.tv_sec = 0;
            timeout.tv_usec = 300000;
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
        } else {
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, NULL);
        }
        if(retVal <= 0 && (errno != EINTR)) {
            if(helloFlag) {
                printf("Timeout - didn't received HELLO\nRemoving client\n");
                removeClinet(cl);
            }
            break;
        }
        if(FD_ISSET(cl -> clientFD, &fds)) // if the fd is in the list
        {
            // receiving massage from client
            if((byteCount = read(cl -> clientFD, inbox, BUFF_SIZE)) <= 0)
            {
                printf("client closed the connection\n");
                removeClinet(cl);
                tcpqFlag = 0;
                break;
            }
            commandType = (uint8_t) inbox[0];
            switch(commandType) {
                case HELLO:
                    if(!helloFlag) {
                        invalid_command(3, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(byteCount != 3) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(inbox[1] || inbox[2]) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    helloFlag = 0;
                    buffer[0] = HELLOACK;
                    temp16 = htons(portUDP);
                    temp32 = htonl(multiCastG[0]);
                    memcpy(buffer + 1, &temp32, 4);
                    memcpy(buffer + 5, &temp16, 2);
                    if(send(cl -> clientFD, &buffer, 7, 0) != 7) {
                        printf("wrong amount of byte sent\n");
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
                    break;
                case INFO:
                    if(helloFlag) {
                        invalid_command(2, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(byteCount != 13) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    /* age,sizename,name got from the client */
                    cl->clientNickNameSize = inbox[2];
                    cl->clientAge = inbox[1];
		    
		    //cl->clientNickName = (char*)malloc(10);
                    //memcpy(cl->clientNickName,inbox[3],cl->clientNickNameSize);  //// todo herrreeeee !!! nickname problem !
                    for (j = 0; j < 4; ++j) {
                        if(IDs[j] == 0)
                        {
                            cl->clientID = j;
                            IDs[j] = 1 ;
                            break;
                        }
                    }
		    
                    memset(buffer, '\0', BUFF_SIZE);
                    buffer[0] = INFOACK;
                    buffer[1] = cl->clientID;
		    buffer[2] = 0 ;
                    if((byteCount = send(cl -> clientFD, &buffer, 3 , 0)) != 3 ) {
                        printf("INFOACK: wrong amount of byte sent\n");
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
		    
                RESUME :
		    
                    while (noOfClients != 4)	
                    if (noOfClients == 4)
                    {
                        memset(buffer, '\0', BUFF_SIZE);
                        buffer[0] = QUESTION;
                        int size0fQ = sizeof(Q1[0]);
                        buffer[1] = size0fQ;
                        memcpy(buffer+2 ,Q1[0],size0fQ);
	                
                        q_now ++ ;
                        if(sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                               (struct sockaddr*) &temp->category,
                                                       sizeof(temp->category)) != (2+size0fQ))
                                                       {
                            printf("FirstQ: wrong amount of byte sent\n"); // change
                               removeClinet(cl);
                               tcpqFlag = 0;
                               break;
                        }
                    }
		    printf("%d\n",noOfClients);

                    break;
                case ANSWER:
			
                        if(helloFlag) {
                            invalid_command(2, cl);
                            tcpqFlag = 0;
                            break;
                        }
                        if(byteCount != 3) {
                            invalid_command(6, cl);
                            tcpqFlag = 0;
                            break;
                        }
                        size0fanswer = inbox[1];
                        memcpy(answers[cl->clientID-1],inbox[2],size0fanswer);
                        // todo wait some time for the data to calculate ? to all the clients
                        scoreCalc();
                        // send another question
                        if(q_now < 5)
                        {
                            memset(buffer, '\0', BUFF_SIZE);
                            buffer[0] = QUESTION;
                            int size0fQ = sizeof(Q1[q_now]);
                            buffer[1] = size0fQ;
                            memcpy(buffer+2 ,Q1[q_now],size0fQ);
                            q_now ++ ;
                            if(sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category)) != (2+size0fQ))
                            {
                                printf("Questions: wrong amount of byte sent\n"); // change
                                removeClinet(cl);
                                tcpqFlag = 0;
                                break;
                            }
                        }
                        else
                        {
                            memset(buffer, '\0', BUFF_SIZE);
                            buffer[0] = FIN;
//                            buffer[1] = 2;
                            /**------------------------------todo--------fill up the winner------------------------------
                            do func that return Number of winner yaani 0011 = 3 = 2 winners id 0+1 (0-3)
                             good year
                             add (sendto(temp->CategoryFD,buffer,2+ size0fQ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category))
                            ***/
                            int winneris = winnerCalc();
                            buffer[1] = winneris ;
                            if(sendto(temp->CategoryFD,buffer,2 ,0,
                                      (struct sockaddr*) &temp->category,
                                      sizeof(temp->category)) != 2)
                            {
                                printf("Winner: wrong amount of byte sent\n"); // change
                                removeClinet(cl);
                                tcpqFlag = 0;
                                break;
                            }
                        }
                case QUIT:
                    if(helloFlag) {
                        invalid_command(2, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    if(byteCount != 3) {
                        invalid_command(6, cl);
                        tcpqFlag = 0;
                        break;
                    }
                    yesno = inbox[1];
                    if(yesno == 0) {
                        removeClinet(cl);
                        tcpqFlag = 0;
                        break;
                    }
                    else
                    {
                        goto RESUME;
                    }
                default:
                    invalid_command(5, cl);
            }//switch
        }//if fd_isset
    }//while 1
}
void scoreCalc()
{
    int min = 3001;
    int temp[4] ;
    for ( i = 0; i < 4; ++i)
    {
        temp[i] = abs(answers[i]-A[q_now]);
        if(min > temp[i])
        {
            min = temp[i];
        }
    }
    for ( i = 0; i < 4; ++i)
    {
        if(temp[i] == min)
        {
            score[i] ++ ;
        }
    }
}

int winnerCalc()
{
    int max = -1 ;
    int k = 1 ;
    for ( i = 0; i < 4; ++i) {
        if(score[i] > max)
        {
            max = score[i];
        }
    }
    for ( i = 0; i < 4; ++i) {
        k = k << 1;
        if(score[i] == max)
        {
            k = k|1;
        }
    }
    return k ;
}

void removeClinet(tcpClient* del)
{
    pthread_mutex_lock(&lock);
    Ttemp = TCPhead;
    IDs[del->clientID] = 0 ;
    if(del == TCPhead) {
        if(del -> next == NULL) {//if there is only one client
            if(close(del -> clientFD) < 0)
                perror("ERROR closing socket\n");
            free(del);
            noOfClients = 0;
            TCPhead = NULL;
        } else {
            Ttemp2 = TCPhead -> next;
            if(close(del -> clientFD) < 0)
                perror("ERROR closing socket\n");
            free(del);
            noOfClients -- ; // noOfClients = 0 ??
            TCPhead = Ttemp2;
        }
    } else {//if del != head
        while(Ttemp != del) {
            Ttemp2 = Ttemp; //holds the prev
            Ttemp = Ttemp -> next;
        }
        Ttemp2 -> next = Ttemp -> next; //prev points to the next problem with NULL ?
        noOfClients--;
        if(close(del -> clientFD) < 0)
            perror("ERROR closing TCP socket\n");
        free(Ttemp);
    }//else
    pthread_mutex_unlock(&lock);

}

void invalid_command(int type , tcpClient *client)
{
    char *str, buffer[BUFF_SIZE];
    int byteCount;
    uint8_t len;
    memset(buffer, '\0', BUFF_SIZE);
    buffer[0] = INVALIDCOMMAND;
    switch(type) {
        case 1:
            printf("Category number given does not exist\n");
            str = "Category number given does not exist";
            len = strlen(str);
            buffer[1] = len;
            break;
        case 2:
            printf("Hello did not sent yet from user and another message was received\n");
            str = "Hello did not sent yet from user and another message was received";
            len = strlen(str);
            buffer[1] = len;
            break;
        case 3:
            printf("More than one HELLO sent\n");
            str = "More than one HELLO sent";
            len = strlen(str);
            buffer[1] = len;
            break;
        case 5:
            printf("Unknown command received\n");
            str = "Unknown command received";
            len = strlen(str);
            buffer[1] = len;
            break;
        case 6:
            printf("Wrong message format\n");
            str = "Wrong message format";
            len = strlen(str);
            buffer[1] = len;
            break;
    }//switch
    memcpy(buffer + 2, str, len);
    if((byteCount = send(client -> clientFD, &buffer, 2 + len, 0)) < 0)
        printf("ERROR sending invalid message\n");
    removeClinet(client);
}

void releaseUdpNode() {
    udpNode *uPtr = head, *uPtr2;
    if(uPtr -> next == NULL) { //only one in the list
        if(close(uPtr -> CategoryFD) < 0)
            perror("ERROR closing TCP socket\n");
        free(uPtr);
    } else {
        uPtr2 = uPtr -> next;
        while(uPtr2 != NULL) {
            if(close(uPtr -> CategoryFD) < 0)
                perror("ERROR closing TCP socket\n");
            free(uPtr);
            uPtr = uPtr2;
            uPtr2 = uPtr2 -> next;
        }
        if(close(uPtr -> CategoryFD) < 0)
            perror("ERROR closing TCP socket\n");
        free(uPtr);
    }
    printf("Released Categories list allocations\n");
}

void releaseTCPclients() {
    tcpClient *aPtr = TCPhead, *aPtr2;
    if(aPtr -> next == NULL) { // there is only one client
        if(close(aPtr -> clientFD) < 0)
            perror("ERROR closing TCP socket\n");
        free(aPtr);
    } else {
        aPtr2 = aPtr -> next;
        while(aPtr2 != NULL) { // close every client and free
            if(close(aPtr -> clientFD) < 0)
                perror("ERROR closing TCP socket\n");
            free(aPtr);
            aPtr = aPtr2;
            aPtr2 = aPtr2 -> next;
        }
        free(aPtr);
    }
    printf("Released client list\n");
    for ( i = 0; i < 4; ++i) {
        IDs[i] = 0;
    }
}

void shutdown_and_goodbye() {
    tcpClient *ptr;
    ptr = TCPhead;
    if(TCPhead != NULL) {
        while(ptr != NULL) {
            pthread_cancel(ptr -> th);
            ptr = ptr -> next;
        }
        releaseTCPclients();
        TCPhead = NULL;
    }
    if(head != NULL) {
        releaseUdpNode();
        head = NULL;
    }
}
