#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/stat.h>

#define BUFF_SIZE 1024
#define SERVER_IP "192.4.5.1"
/*messages we send*/
#define HELLO 0
#define INFO 1
#define ANSWER 2
#define QUIT 3
#define FIRSTQ 4

/*messages we recive*/
#define HELLOACK 0
#define INFOACK 1
#define QUESTION 2
#define FIN 3
#define INVALIDCOMMAND 4

void shutdown_and_goodbye();
void whoWin(int i);

uint8_t commandType,age;
uint16_t reserved, server_port;
uint32_t multicastGroup;
int yes = 1 ;
struct in_addr temp;
//UDP Socket and streaming initialing
int udp_sock, client_socket_fd,  qFlag = 1, question_f = 5;
struct sockaddr_in serv_addr;

int main(int argc, char *argv[]) {
    //declaring variables
    int port_no, num_parts, byte_no, retVal;
    int flag_c = 1 ;
    struct ip_mreq mreq;
    int len , maxfdp1;
    char *str;
    char quesionbuff[BUFF_SIZE + 1];
    int askFlag = 0, permitFlag = 0, newFlag = 0;
    char buffer[BUFF_SIZE + 1], inbox[BUFF_SIZE + 1], input[10], *songAnnounced, *replyString, recName[201], answer[4];
    buffer[BUFF_SIZE] = '\0';
    char nickname[10];
    int sizeofnickname, lenth;
    char buff[3];
    uint8_t replyStringSize;
    fd_set fds , fdu;
    FILE *fp;
    struct sockaddr_in server_addr;
    struct stat st;
    memset(buffer, '\0', BUFF_SIZE);

    //struct for Timeout in select
    struct timeval timeout;

    // Read command line arguments, need to get server name(ip) and server port (number)
    if (argc != 2) {
        perror("num of arguments is incorrect\n");
        exit(EXIT_FAILURE);
    }
    // Convert the port argv to the appropriate data type
    port_no = atoi(argv[1]);


    // setup the TCP socket
    if((client_socket_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("ERROR openning socket");
        exit(EXIT_FAILURE);
    }

    // clear our the struct server_addr
    memset((char *) &server_addr, 0, sizeof(server_addr));

    // set up the TCP socket 1
    server_addr.sin_family = AF_INET; //IPv4
    server_addr.sin_port = htons(port_no); //host to network byte order
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP); //turn char to int as needed in the struct
    memset(server_addr.sin_zero, '\0', sizeof(server_addr.sin_zero));

    // trying to connect to the server (TCP socket)
    if (connect(client_socket_fd,(struct sockaddr *) &server_addr,sizeof(server_addr)) < 0) {
        perror("ERROR connecting");
        exit(EXIT_FAILURE);
    }
    printf("Sending Hello\n");
    //send hello
    byte_no = 0;
    reserved = 0;
    memset(buff, '\0', 3);
    buff[0] = HELLO;
    buff[1] = htons(reserved);
    byte_no = send(client_socket_fd,&buff,sizeof(buff),0);
    if(byte_no != 3) {
        printf("ERROR sending Hello\nClosing socket and communication\n");
        if(close(client_socket_fd) < 0) {
            perror("ERROR closing TCP socket\n");
        }
        exit(EXIT_FAILURE);
    }
    //wait for response using select
    timeout.tv_sec = 0;
    timeout.tv_usec = 300000;

    /*waiting for Welcome*/
    FD_ZERO(&fds);
    FD_SET(client_socket_fd, &fds);
    retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
    if(retVal <= 0 && (errno != EINTR)) {
        perror("Timeout - didn't received WELCOME\nClosing the communication\n");
        if(close(client_socket_fd) < 0)
            perror("ERROR closing TCP socket\n");
        exit(EXIT_FAILURE);
    }
    if((byte_no = read(client_socket_fd, inbox, BUFF_SIZE)) <= 0) {
        perror("Can not read from socket\nClosing socket and communication\n");
        if(close(client_socket_fd) < 0)
            perror("ERROR closing TCP socket\n");
        exit(EXIT_FAILURE);
    }
    commandType = (uint8_t) inbox[0];
    if(commandType != HELLOACK) {
    	perror("Message type is not Welcome\nClosing socket and communication\n");
        if(close(client_socket_fd) < 0)
            perror("ERROR closing TCP socket\n");
        exit(EXIT_FAILURE);
    }
    if(byte_no != 7) {
    	perror("Wrong message format\nClosing socket and communication\n");
        if(close(client_socket_fd) < 0)
            perror("ERROR closing TCP socket\n");
        exit(EXIT_FAILURE);
    }
    NICK:
    memset(buffer, '\0', BUFF_SIZE);
    printf("Please enter your nickname (no longer then 10 letters):\n");
    buffer[0] = INFO;
    scanf("%s",nickname);
    sizeofnickname = sizeof(nickname);
//    printf("sizeofnickname: %d\n",sizeofnickname); /////////// todo take care of tht
//    if(sizeofnickname > 10 )
//    {
//        printf("please try again, you have entered more than 10 letters\n");
//        goto NICK;
//    }
    printf("Please enter your age (0-99):\n");
    scanf("%d",&age);
    buffer[1] = age;
    buffer[2] = sizeofnickname;
    memcpy(buffer+3,nickname,sizeofnickname);
    if((num_parts = send(client_socket_fd, &buffer, 3+sizeofnickname, 0)) != 3+sizeofnickname) {
        perror("ERROR in sending INFO\n");
        shutdown_and_goodbye();
        exit(EXIT_FAILURE);
    }
    memset(buffer, '\0', BUFF_SIZE);
    /*handle welcome*/
    multicastGroup = htonl(*(((uint32_t*) (&(inbox)[1]))));
    server_port = htons(*(((uint16_t*) (&(inbox)[5]))));
    temp.s_addr = multicastGroup;
    // routine with SERVER
    printf("Welcome to intTrivia game!!\n");
    printf("The number of question is: 5 \n multicastGroup is: %s \n serverPort is: %u\n",inet_ntoa(temp),server_port);

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = server_port;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

	udp_sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (udp_sock < 0) {
	printf("error in opening udp socket\n");
	qFlag = 0;
	shutdown_and_goodbye();
	exit(EXIT_FAILURE);
	}
	FD_SET(udp_sock,&fds);
	u_int yes = 1;
	if (
	setsockopt(
	udp_sock, SOL_SOCKET, SO_REUSEADDR, (char*) &yes, sizeof(yes)
	) < 0
	){
	  perror("Reusing ADDR failed");
	  return 1;
	}
	struct sockaddr_in addr;
	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY); // differs from sender
	addr.sin_port = htons(6000);

	printf("open udp sock\n");
	if (bind(udp_sock, (struct sockaddr *) &addr, sizeof(addr)) != 0) {
	perror("UDP bind failed\n");
	qFlag = 0;
	shutdown_and_goodbye();
	exit(EXIT_FAILURE);
	}

	printf("bind udp sock\n");
	mreq.imr_multiaddr.s_addr = inet_addr("224.4.0.5");
	mreq.imr_interface.s_addr = htonl(INADDR_ANY);

	if (setsockopt(udp_sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) != 0) {
	perror("ERROR on setsocketopt\n");
	qFlag = 0;
	shutdown_and_goodbye();
	exit(EXIT_FAILURE);
	}
	FD_SET(udp_sock, &fds);
	// here udp sock
   

    while(qFlag) {
		FD_ZERO(&fds);
		FD_SET(client_socket_fd,&fds);
		FD_SET(udp_sock, &fds);
		FD_SET(fileno(stdin), &fds);
        //wait for response using select
        if(newFlag) {
            timeout.tv_sec = 2;
            timeout.tv_usec = 0;
        } else {
            timeout.tv_sec = 15;
            timeout.tv_usec = 0;
        }
        memset(buffer, '\0', BUFF_SIZE);
        memset(quesionbuff, '\0', BUFF_SIZE);
        printf("At any time you can type 'q' to quit.\n");
        if(newFlag)
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
        else
            retVal = select(FD_SETSIZE, &fds, NULL, NULL, NULL);
        if(retVal <= 0 && (errno != EINTR)) {
            if(newFlag) {
                printf("Timeout - new connection\n");
                shutdown_and_goodbye(); //closing thread & sockets
            }
            exit(EXIT_FAILURE);
        }
        printf("search for UDP/TCP\n");
        if(FD_ISSET(fileno(stdin), &fds)) {
            scanf("%10s",input);
            switch (input[0]) {
                case 'q':
                    qFlag = 0;
                    break;
                default :
                    printf("Please enter 'q' to quit\n");
            }//switch
            memset(input, '\0', sizeof(input));
        } // if input - stdin
        else if(FD_ISSET(udp_sock, &fds)){
        printf("arrive Multicast read!\n");
        if((byte_no = read(udp_sock, quesionbuff, BUFF_SIZE)) < 0) {
                perror("The server closed the connection!\n");
                shutdown_and_goodbye();
                exit(EXIT_FAILURE);
            }
        commandType = (uint8_t) quesionbuff[0];
      switch(commandType) {
case QUESTION:
   printf("arrive Question case!\n");
   if (question_f > 0) {
	    timeout.tv_sec = 15;
	    timeout.tv_usec = 0;
	    FD_ZERO(&fds);
		FD_SET(fileno(stdin), &fds);
		question_f--;
		len = quesionbuff[1];
		str = (char *) malloc(len + 1);
		memcpy(str, quesionbuff +2 , len + 1 );
		printf("%s\n", str);
		printf("type your answer:\n");
		retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
		if (retVal == 0)
		{
			printf("Timeout - gain 0 points\n");
			buffer[0] = ANSWER;
			answer[0]= 'ff';
			answer[1]= 'ff';
			answer[2]= 'ff';
			answer[3]= 'ff';
			buffer[1] = strlen(answer);
			memcpy(buffer + 2, answer, strlen(answer));
			if ((num_parts = send(client_socket_fd, &buffer, 2 + strlen(answer), 0)) != (2 + strlen(answer))) {
			   perror("ERROR in sending first ANSWER\n");
			   shutdown_and_goodbye();
			   exit(EXIT_FAILURE);
			}
			break;
		}
		if(FD_ISSET(fileno(stdin), &fds))
		{
			scanf("%s", answer);
			buffer[0] = ANSWER;
			buffer[1] = strlen(answer);
			memcpy(buffer + 2, answer, strlen(answer));
			if ((num_parts = send(client_socket_fd, &buffer, 2 + strlen(answer), 0)) != (2 + strlen(answer))) {
			   perror("ERROR in sending first ANSWER\n");
			   shutdown_and_goodbye();
			   exit(EXIT_FAILURE);
				}
			}

		} else {
				perror("Wrong message type - question have already asked\n");
				shutdown_and_goodbye();
				exit(EXIT_FAILURE);
		   }
		   break;
	case FIN:
                    if (byte_no != 2) {
                        perror("Wrong message format\n");
                        shutdown_and_goodbye();
                        return 1;
                    }
                    FD_ZERO(&fds);
					FD_SET(fileno(stdin), &fds);
                    whoWin((uint8_t )quesionbuff[1]);
					  printf("Do you want to keep playing (Y/N)?\n");
					  char* yesno;
				    retVal = select(FD_SETSIZE, &fds, NULL, NULL, &timeout);
					if (retVal == 0)
					{
						buffer[0] = QUIT;
						buffer[1] = 0;
						if ((num_parts = send(client_socket_fd, &buffer, 2, 0)) != 2) {
							perror("ERROR in sending first ANSWER\n");
							shutdown_and_goodbye();
							exit(EXIT_FAILURE);
						}
						printf("Bye Bye");
						shutdown_and_goodbye();
						return 0;
					}
					if(FD_ISSET(fileno(stdin), &fds)){
					  scanf("%1s", &yesno);
					  printf("yesno :%c\n",yesno);
					  if (yesno == 'Y' || yesno == 'y') {
						buffer[0] = FIRSTQ;
						buffer[1] = 1;
						buffer[2] = 0;
						question_f = 5 ;
						if ((num_parts = send(client_socket_fd, &buffer, 3, 0)) != 3) {
							perror("ERROR in sending first ANSWER\n");
							shutdown_and_goodbye();
							exit(EXIT_FAILURE);
						}
                        //goto RESUME;
					  } else if (yesno == 'N' || yesno == 'n') {
							buffer[0] = QUIT;
							buffer[1] = 0;
							if ((num_parts = send(client_socket_fd, &buffer, 2, 0)) != 2) {
								perror("ERROR in sending first ANSWER\n");
								shutdown_and_goodbye();
								exit(EXIT_FAILURE);
							}
							printf("Bye Bye");
							shutdown_and_goodbye();
							return 0;
                    } else {
                        printf("please type only (Y/N)\n");
                    }
                    break;
					}
	}

}
        else if(FD_ISSET(client_socket_fd, &fds)) {
            printf("Got a message from server\n");
            if((byte_no = read(client_socket_fd, inbox, BUFF_SIZE)) <= 0) {
                perror("The server closed the connection!\n");
                shutdown_and_goodbye();
                exit(EXIT_FAILURE);
            }

            commandType = (uint8_t) inbox[0];
            switch(commandType) {
                case HELLOACK:
                    /*we already deal with welcome = received more than one*/
                    printf("More than one WELCOME received\n");
                    shutdown_and_goodbye();
                    exit(EXIT_FAILURE);
                    break;
                case INFOACK:
           if (byte_no != 3) {
               printf("Wrong message format\n");
               shutdown_and_goodbye();
               exit(EXIT_FAILURE);
           }
           // open udp socket - listen to the first question via multicast
           printf("before sock\n");
           //if (setsockopt(udp_sock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) != 0) {
           //    perror("ERROR on setsocketopt1\n");
           //    qFlag = 0;
            //   shutdown_and_goodbye();
           //    exit(EXIT_FAILURE);
          // }

				printf("open udp sock\n");
				printf("setsockpot udp sock\n");
				//RESUME:
				buffer[0] = FIRSTQ;
				buffer[1] = 0;
				buffer[2] = 0;
				if((num_parts = send(client_socket_fd, &buffer, 3, 0)) != 3) {
				perror("ERROR in sending INFO\n");
				shutdown_and_goodbye();
				exit(EXIT_FAILURE);
				}
				printf("before\n");
				lenth = sizeof(addr);
				//if(recvfrom(udp_sock, quesionbuff, BUFF_SIZE, 0,
								  // (struct sockaddr *)&addr, &lenth)<0)
				//{
				// perror("recvfrom \n");
				//}
				//printf("%d\n",quesionbuff[0]);
				FD_ZERO(&fds);
				FD_SET(udp_sock,&fds);
				break;

                case INVALIDCOMMAND:
                    len = inbox[1];
                    str = (char *) malloc(len + 1);
                    if (!str) {
                        perror("malloc fail\n");
                        shutdown_and_goodbye();
                        exit(EXIT_FAILURE);
                    }
                    memcpy(str, inbox +2 , len +1 );
                    printf("%s\n", str);
                    shutdown_and_goodbye();
                    exit(EXIT_FAILURE);
                    break;
            }
             memset(inbox, '\0', sizeof(inbox));
        }//if msg from server
    }//while qFlag
    shutdown_and_goodbye();
    return 0;
}//main


void shutdown_and_goodbye()
{
    if(close(client_socket_fd) < 0)
        perror("ERROR closing TCP socket");
    if(close(udp_sock) < 0 )
        perror("ERROR closing UDP socket");
    printf("closed communication, bye\n");
}

void whoWin(int i)
{
    int arr[4] = {0,0,0,0};
    int j ;
    if(i==17 ||i==18 ||i==20 ||i==24)
    {
        printf("the winner is:\n");
    }
    else
        printf("the winners are:\n");
    for (j = 3; j >-1 ; --j) {
        if(i%2 == 1)
        {
            arr[j] = 1 ;
            printf("id %d\n",j);
        }
        i = i >> 1 ;
    }
}

